#(Like a)Interpreter
文字通りインタープリタ的なものです.  
make コマンドでbuildできます.make clean で生成したオブジェクトファイルを削除します.  
直接実行モードでは"( ) + * / % "などが使えます。演算子の優先順位も定義 。()を含んだ式も評価可能です。(したつもりだったけどうまくいってない。そのうち直す.)また、グローバル環境に変数を束縛できます。(ex. hoge = 100)。if,else,などの構文っぽいものは予約語なので使えません.  
インタープリタを起動したあと、"load ファイル名"でファイルを読み込み、"run"で実行します。プログラムの一行目から順番にコードを追いつつ、メモリ上に保存しているため、ネストしていたり、再帰的なコードは実行できないです.  


****
## <<直接実行モードコマンド>>

* "quit" or "exit":プログラムを終了.  
* printvar(pv): 変数を表示.  
* printstack(ps): スタックを表示.   
* print x: x(任意の式)を評価し出力(改行なし).   
* println x:  x(任意の式)を評価し出力(改行あり)  




****
## <<文法>>  
* メインモジュールを定義していないので、プログラムの一行目から"end"までを実行.  
* "def 関数名 処理　enddef"でサブルーチンを定義します.  
* "call 関数名"でサブルーチンを呼び出します。引数も指定できます.  
* "if 条件式 then 処理 else 処理 endif"で条件分岐(elseは省略可）  
* "for 初期化(ex.i=0) to　終了条件 処理 next i"で繰り返し.  
* pritvarで変数表を出力します。(pvでも可)  
* printstackでスタックの内容を表示します。(psでも可)  
* "print x"でxを表示します.  
* "println x"でxを表示したあと改行します.  
* "TokenStat"でトークンの状態を出力しながら処理する。(tsでも可).  
* "DispLine"で実行中の行を出力しながら処理する。(dlでも可).  
* ”StackStat"でスタックの状態を出力しながら処理する。(ssでも可).  
